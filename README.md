## Отчет по лабораторной работе № 1

#### № группы: `ПМ-2502`

#### Выполнил: `Пашенко Виталий Витальевич`

#### Вариант: `13`

### Cодержание:

- [Постановка задачи](#1-постановка-задачи)
- [Входные и выходные данные](#2-входные-и-выходные-данные)
- [Выбор структуры данных](#3-выбор-структуры-данных)
- [Алгоритм](#4-алгоритм)
- [Программа](#5-программа)
- [Анализ правильности решения](#6-анализ-правильности-решения)

### 1. Постановка задачи

> Ваша задача – посмотреть, какие значения принимает последовательность при разных a0 и n, вывести закономерность, по которой строится последовательность и запрограммировать ее самостоятельно.

1, 1, 2, 1, 2, 2, 3, 1, 2, 2, 3, 2, 3, 3, 4, 1, 2, 2, 3, 2, 3, 3, 4, 2, 3, 3, 4, 3, 4, 4 - первые 30 элементов последовательности. Можно заметить, что каждая цифра послежовательности соотвествует количеству единиц в двоичной форме записи числа, то есть числу один соотвествует 1, двойке - 1, т. к. дв. запись 10, тройке - 2, т. к. дв. запись 11, и так далее. Также, в ходе исследования посследовательности, я заметил, что она не зависит от первого элемента, значит его можно даже не вводить.
Значит нам необходимо написать программу, которая выводит на экран количество единиц в двоичной записи для чисел от 1 до n.

### 2. Входные и выходные данные

#### Данные на вход

На вход программа получает только 1 число - длинну последовательности, так как искомый ряд не зависит от первого элемента. Так как количество элементов это натуральное число, то воспользуемся типом данных `int`.
|             | Тип                              | min значение    | max значение     |
|-------------|----------------------------------|-----------------|------------------|
| n (Число 1) | Натуральное число                | 1               | 2<sup>31</sup>-1 |\

#### Данные на выход

В программе мы не храним данные, а сразу выводим результат, который является натуральным числом.

### 3. Выбор структуры данных

Программа получает натуральное число, не превышающее 2<sup>31</sup>-1. Для его хранения потребуется 1 переменных `n` типа `int`.

### 4. Алгоритм

1. **Ввод данных:**  
   Программа считывает натуральное число, обозначенное как `n`.

2. **Перевод в двоичную систему:**  
   Программа переводит числа от 1 до `n` в двоичную систему счисления.
   
3. **Вывод результата:**  
   На экран выводится по очередно количество единиц в двоичной форме записи числа, принадлежащему промежутку от 1 до `n`.
   
### 5. Программа

Полный текст программы с комментариями на русском языке

```java
import java.io.PrintStream;
import java.util.Scanner;

public class Task1 {
    public static Scanner in = new Scanner(System.in);
    public static PrintStream out = System.out;
    static String dv(int a){
        if (a == 0)
            return "";
        return dv(a/2) + ""  + a%2; // Это рекурентная функция, которая вычисляет двоичную форму записи числа и запоминает её как строку.
    }
    public static void main(String[] args) {
        int q = in.nextInt(); // Вврл длины последовательности.
        for (int i = 1; i<=q; i++){
            String w = dv(i); // Вызов функции, возвращающей двоичную форму записи числа.
            int e = 0; // Счетчик количества единиц.
            for (int j = 0; j < w.length(); j++){ // В цикле проходим по двоичному числу и считаем количество единиц в нем.
                if (w.charAt(j) == '1')
                    e++;
            }
            out.print(e + ", "); // Выводим количество единиц для каждого числа.
        }
    }
}
```

### 6. Анализ правильности решения
Программа выводит последовательность, совпадающую с последовательностью из условия.

   - **Input**:
        ```
        30
        ```

   - **Output**:
        ```
        1 1 2 1 2 2 3 1 2 2 3 2 3 3 4 1 2 2 3 2 3 3 4 2 3 3 4 3 4 4
        ```

### Cодержание:

- [Постановка задачи](#7-постановка-задачи)
- [Входные и выходные данные](#8-входные-и-выходные-данные)
- [Выбор структуры данных](#9-выбор-структуры-данных)
- [Алгоритм](#10-алгоритм)
- [Программа](#11-программа)
- [Анализ правильности решения](#12-анализ-правильности-решения)

### 7. Постановка задачи

> Дана последовательность из n чисел. Найти самую длинную подпоследовательность идущих подряд элементов, которую можно сделать возрастающей, удалив из нее 1 элемент. Вывести ее длину и индексы первого элемента и элемента, который необходимо убрать. Если таких подпоследовательностей несколько, вывести результат для той, что встречается раньше остальных.
В данной задачи нам необходимо сравнивать соседние числа, пока мы не наткнемся на ситуацию: правое число больше левого. В таком случае мы удаляем этот элемент и "пропускаем" его. Если эта ситуация повторяется, то мы проверяем, получили ли мы максимальную подпоследовательность. Если да, то запоминаем длину и искомые индексы и начинаем проверку, начиная с удаленного элемента. Иначе просто начинаем проверку с удаленного элемента. После прохождения цикла выводим найденные значения, причем индексы в последовательности нумеруются с 1.

### 8. Входные и выходные данные

#### Данные на вход

На вход программа получает число `n` - количество элементов последовательности и сами `n` элементов. Элементы последовательности будет необходимо хранить в списке. Для всех переменных воспользуемся типом данных `int`.
|             | Тип                              | min значение    | max значение     |
|-------------|----------------------------------|-----------------|------------------|
| n (Число 1) | Натуральное число                | 1               | 2<sup>31</sup>-1 |
|Ряд из n чисел| Целые числа               | -2<sup>31</sup> | 2<sup>31</sup>-1 |

#### Данные на выход

Для вывода нам потребуется 3 целочисленных переменных. `m` - максимальная длина подпоследовательности, это натуральная величина. `indo` - индекс элемента, с которого мы начинаем последовательность. `indo` - индекс элемента, который мы удаляем. Он может быть равен 0, это означает, что никакой элемент удалять не нужно.

|             | Тип                              | min значение    | max значение     |
|-------------|----------------------------------|-----------------|------------------|
| m (Число 1) | Натуральное число                | 1               | 2<sup>31</sup>-1 |
| indo (Число 2)| Натуральное число                | 1 | 2<sup>31</sup>-1 |
| inddo (Число 3) | Целое число               | 0 | 2<sup>31</sup>-1 |


### 9. Выбор структуры данных

Программа получает натуральное число, не превышающее 2<sup>31</sup>-1. Затем еще ряд целых чисел принадлежащих промежутку от -2<sup>31</sup> до 2<sup>31</sup>-1. Для хранения первого числа воспользуемся перменной типа `int`, а для последовательности потрубется массив длинны `n`, хранящий значения типа `int`.

### 10. Алгоритм

1. **Ввод данных:**  
   Программа считывает натуральное число, обозначенное как `n`. Затем заполняет массив `a` из введенных элементов. 

2. **Начальный индекс:**
   Программа выбирает индекс, с которого начинает исследовать введенную последовательность и переменный индекс(индекс левого элемента).
   
3. **Сравнение чисел, если правое больше:**
   Программа сравнивает два рядом стоящих числа(правое больше)
   
      **a)**
         Если еще никакой элемент не был "удален" из последовательности, то мы увеличиваем на 1 счетчик длины последовательности и индекс левого числа в сравнении.
   
      **b)**
         Иначе мы индекс левого числа в сравнении становится равным индексу правого числа и увеличиваем счетчик длины последовательности на 1.
   
5. **Сравнение чисел, если правое меньше:**
      Иначе (левое больше)
   
      **a)**
         Если еще никакой элемент не был "удален" из последовательности, то мы меняем флаг отвечающий за "удаленные' элементы, запоминаем индекс "удаленного" (пропущенного) элемента и увеличиваем на 1 счетчик длины последовательности.
   
      **b)**
         Иначе сравниваем значение получившийся длины со значением максимальной длины. Если получившееся значения больше, то запоминаем его как максимальное значение, запоминаем индекс первого элемента подпоследовательности и индекс удаленного элемента из подпоследовательности. Также возвращаем в начальное значение флаг, индекс начального элемента, индекс удаленного элемента и счетчик длины, а переменный индекс становится индексом удаленного элемента(до возвращения в начальное значение).
   
3. **Вывод результата:**  
   На экран выводится по очередно максимальная длинна подпоследовательности, индекс первого элемента подпоследовательности и индекс удаленного элемента из подпоследовательности.
   
### 11. Программа

Полный текст программы с комментариями на русском языке

```java
import java.io.PrintStream;
import java.util.Scanner;

public class Task2 {
    public static Scanner in = new Scanner(System.in);
    public static PrintStream out = System.out;
    public static void main(String[] args) {
        int n = in.nextInt(); // Ввод длины последовательности
        int c = 0; // Переменный счетчик длины
        int k = 1; // Флаг удаленного элемента
        int ind1 = -1; // Индекс начального элемента исследуемой последовательности
        int indo = 0; // Индекс начального элемента максимальной подпоследовательности
        int indd = -1; // Индекс "удаленного" элемента исследуемой последовательности
        int inddo = 0; // Индекс "удаленного" элемента максимальной подпоследовательности
        int indz = 0; // Переменный индекс
        int m = 0; //Длина максимальной последовательнсоти
        int[]a = new int[n]; // Задаем массив, где будем хранить последовательность
        for (int i = 0; i<n; i++){
            a[i] = in.nextInt(); // Ввод последовательности
        }
        for (int i = 1; i<n; i++){
            if (ind1 == -1) { // Если индекс начального элемента имеет начальное значение, то задаем его и переменный индекс
                ind1 = i - 1;
                indz = i - 1;
            }
            if (a[indz] < a[i]){ // Сравниваем соседние числа
                if (k == 1) { // Если элемент не удален и числа подходят, то увеличиваем левый индекс и длину на 1
                    c++;
                    indz++;
                }
                else{ // Иначе (числа все еще подходят) увелчиваем длинну, а левый индекс становится правым, чтобы проскачить удаленный элемент
                    c++;
                    indz=i;
                }
            }
            else // Если не подходят (левое больше или равно правому)
                if (k == 1){ // Если еще не удаляли элемент, то меняем флаг, запоминаем индекс удаленного и увеличиваем длину
                    k = 0;
                    indd = i;
                    c++;
                }
               else{
                   if (m < c) { //Иначе сравниваем максимальную длину с переменной. Если максимальная меньше, то она становится переменной. Также запоминаем индексы начального и удаленных элементов
                       m = c;
                       inddo = indd;
                       indo = ind1;
                   }
                   k = 1; // Возвращаем в начальное значения все элементы кроме счетчика цикла
                   ind1 = -1;
                   i = indd; // Его мы делаем равным индексу удаленного элемента, чтобы новая последовательность, которую мы исследуем, содержала все значимые числа
                   indd=-1;
                   c = 0;
               }
        }
        if (m < c && m == 0) { // Эта проверка нужна, потому что если исходная последовательность была подходящий по условию (то есть изначально возрастающая или нужно было удалить только один элемент и она сразу становилась максимальной возрастающий, то есть не нужно было проверять остальные подпоследовательности
            m = c;
            inddo = indd;
            indo = ind1;
        }
        out.print((m+1) + " " + (indo + 1) + " " + (inddo+1));

    }
}
```

### 12. Анализ правильности решения
   Нам необходимо удалить 4 элемент, тогда будем иметь возрастающую подпоследовательность из всех оставшихся чисел.
   - **Input**:
        ```
        7
        1 2 4 3 5 6 7
        ```

   - **Output**:
        ```
        7 1 4
        ```
   Удалять элементы не нужно, так как исходная последовательность сразу является подходящей под условие.
   - **Input**:
        ```
        5
        1 2 3 4 5 
        ```

   - **Output**:
        ```
        5 1 0
        ```
   Первая подпостедовательность максимальной длины - 1 3 2 4 6 (необходимо удалить третий элемент, то есть двойку)
   - **Input**:
        ```
        6
        1 3 2 4 6 5
        ```

   - **Output**:
        ```
        5 1 3
        ```

        
